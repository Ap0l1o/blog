{"componentChunkName":"component---src-components-post-post-jsx","path":"/2013-01-06-principles-of-computer-graphics/","result":{"data":{"markdownRemark":{"html":"<p>The specification for this assignment was to create a basic 3D scene with mutliple objects, camera control, and various graphical effects under the title <em>Mars in Fiction</em>.</p>\n<p>The scene had to be written in C++ and use OpenGL, and ‘modern’ OpenGL techniques that have been the standard since version 3, such as the use of vertex and fragment shaders, and vertex arrays.</p>\n<h4 id=\"out-of-date-documentation\" style=\"position:relative;\"><a href=\"#out-of-date-documentation\" aria-label=\"out of date documentation permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Out of Date Documentation</h4>\n<p>This was by far the biggest issue I had while developing the scene. Our lectures were on the theory behind 2D and 3D graphics, covering algorithms, matrix mathematics, lighting models, and more. But we were given very little in the way of explained code samples, most of this we were expected to research ourselves.</p>\n<p>The problem is that OpenGL changed significantly between versions 2 and 3, and becuase now the developer must deal with buffering data for the graphics hardware, and write code in the OpenGL Shading Language (GLSL), I think it has become considerably more difficult for beginners as so many new concepts need to be learnt for even the most basic applications.</p>\n<p>Unfortunately when writing OpenGL applications, and googling for help on obscure error codes, much of the help is for version 2. This is often difficult, or impossible, to translate into the modern methods of using OpenGL.</p>\n<p>There are some great resources for learning OpenGL, such as <a href=\"http://www.opengl-tutorial.org\">opengl-tutorial.org</a>, but it’s one of very few recent resources, so if you encounter problems, it can be very difficult to find more help.</p>\n<h4 id=\"hardware-compatibility\" style=\"position:relative;\"><a href=\"#hardware-compatibility\" aria-label=\"hardware compatibility permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hardware Compatibility</h4>\n<p>The programming I’ve done in the past has rarely been tied so closely to the hardware. I wrote some code to run on an <a href=\"http://www.stm32circle.com/resources/stm32primer2.php\">STM32 Primer2</a> last year, and that required being constantly aware of the hardware in the device and it’s harsh limitations, but at least there was only one hardware standard across the several devices I used.</p>\n<p>I spent a considerable amount of time working out the versions of OpenGL and GLSL that I was able to use on my computer, and that were available on the computer this would be marked on. Eventually I discovered after much trial and error, that I could use OpenGL 3.2 and GLSL 330 core. The process wasn’t intuitive, and even finding out the version that I had on my computer was not easy with confliciting information online.</p>\n<h4 id=\"application-architecture\" style=\"position:relative;\"><a href=\"#application-architecture\" aria-label=\"application architecture permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Application Architecture</h4>\n<p>One of the most difficult things I found about this assignment was not using new APIs that involved terminology I didn’t understand, or learning C++ which I had no previous experience with. It was deciding how to structure the application at a high level.</p>\n<p>When I write a web application in Python, I would generally use Django, which would tell me where to put my view code, where to put templates, how to write URL schemes, and so on. Cocoa applications on Mac OS have a fairly well defined structure as well. But when dealing with OpenGL, which isn’t object oriented in any way, it can be difficult to work out where particular parts of the code should go.</p>\n<p>Is it safe to buffer all the scene objects into graphics memory? Should objects be responsible for animating themselves? Do these variables need to be given to the shaders, and if so, how? These are all questions that seem quite daunting when writing the first few lines of code, because the structure may need to change significantly later on if one of them is wrong.</p>\n<p>By the end of the assignment, I had ended up with a simple, but fairly capable mini framework for a lot of this. It’s not perfect, but with a few hours to refactor some parts, and write code to dynamically load scenes and animations, it could be much better.</p>\n<h4 id=\"conclusion\" style=\"position:relative;\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h4>\n<p>There is a need for a graphics <em>framework</em>. OpenGL provides a great API, but no hint about how an application should be structured. There are game engines out there that will do this, but I don’t think the answer is to learn a game engine instead.</p>\n<p>All that is really needed is a basic structure of probably no more than a dozen or so classes with basic scene object handling, shader setup, graphics pipeline and texturing. Possibly the most complex part that I think is desparately needed is handling for hardware compatibility – a way to abstract some of the main differences away from the graphics novice.</p>\n<p>Most crucially though, the framework must be documented. Examples of how to show a textured cube, through to how to create a basic animated scene, would be very useful to many students and aspiring game developers.</p>\n<p>Here’s what my final scene looked like. It’s very basic, but written to fulfil the assignment specification. I would have liked to spend more time making it nicer, perhaps with bump mapping, material loading, or smooth animation, but with exams coming in the next few weeks I unfortunately don’t have enough time.</p>\n<div class=\"gatsby-resp-iframe-wrapper\" style=\"padding-bottom: 64.33333333333333%; position: relative; height: 0; overflow: hidden; \" > <iframe src=\"https://player.vimeo.com/video/56837082?byline=0&amp;portrait=0&amp;color=d60002\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen style=\" position: absolute; top: 0; left: 0; width: 100%; height: 100%; \"></iframe> </div>\n<br/>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n  }\n  \n  .grvsc-code {\n    display: inline-block;\n    min-width: 100%;\n  }\n  \n  .grvsc-line {\n    display: inline-block;\n    box-sizing: border-box;\n    width: 100%;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-line-highlighted {\n    background-color: var(--grvsc-line-highlighted-background-color, transparent);\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, transparent);\n  }\n  \n</style>","fields":{"slug":"/2013-01-06-principles-of-computer-graphics/"},"frontmatter":{"title":"Principles of Computer Graphics","theme":null,"originally_on_thread":null,"date":"06 January, 2013"}},"site":{"siteMetadata":{"title":"Dan Palmer","description":"Personal site and blog"}}},"pageContext":{"slug":"/2013-01-06-principles-of-computer-graphics/"}}}