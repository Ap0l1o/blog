{"componentChunkName":"component---src-components-post-post-jsx","path":"/2016-06-19-starting-snap/","result":{"data":{"markdownRemark":{"html":"<p>Following on from my <a href=\"https://danpalmer.me/blog/haskell-web-frameworks\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">previous post</a> about Haskell web frameworks, I wanted to dive into actually making something with my favourite of the lot. Snap gives you a lot right out of the box, but setting up an application to the point where it can talk to a database in a useful way (i.e. not untyped raw queries) takes a little bit of work.</p>\n<p>Note: Since my goal here is to <em>learn</em>, and do things the “right way”, I’m not worrying too much about productivity or whether these solutions are proportionate to the problem I’m trying to solve. There are certainly simpler ways that would have sufficed (i.e. dropping authentication, using a simpler templating system, or using <a href=\"https://hackage.haskell.org/package/postgresql-simple\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">postgresql-simple</a>).</p>\n<p>My requirements for this project were:</p>\n<ul>\n<li>To write <em>idiomatic</em> Snap, making good use of Snaplets.</li>\n<li>To use modern Haskell development tooling, like Stack, and up-to-date libraries.</li>\n<li>To interface to the database with a high-level, type-safe interface, in this case Persistent and Esqueleto.</li>\n</ul>\n<h3 id=\"setting-up-snap\" style=\"position:relative;\"><a href=\"#setting-up-snap\" aria-label=\"setting up snap permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Setting up Snap</h3>\n<p>In the interests of writing idiomatic Snap code, I wanted to start from a project template. The <code>snap</code> binary has the ability to generate several template projects, so I installed it into my global Stack environment, and ran <code>snap init</code> in a new directory.</p>\n<p>The snap starter template is a little out of date, with a few packages that need updating if we want to use the latest LTS from Stackage, and with support for older versions of packages and the GHC compiler that we’re unlikely to need.</p>\n<p>First off, let’s remove the flag for the old version of <code>base</code>, we won’t need it. <a href=\"https://github.com/danpalmer/snap-starter/commit/747aba1fe276d79acce8e0af3c7ac2a10f8a8e45\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">747aba1f</a></p>\n<p>Next, we can remove support for GHC 6.x. We’re on 7.x and 8.x is now out, so we won’t need this either. <a href=\"https://github.com/danpalmer/snap-starter/commit/6ec445292ac62ed85f810e09cc7e84c55bcb6656\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">6ec44529</a></p>\n<p>The snap template gives us a Cabal-based project, but we don’t have the necessary configuration for Stack yet. It’s generally easy to add this with <code>stack init</code>, however there are a few dependencies that we can’t resolve with the project in its current state. By bumping a few versions and adding other packages as extra dependencies, we can create a basic <code>stack.yml</code> <a href=\"https://github.com/danpalmer/snap-starter/compare/6ec445292ac62ed85f810e09cc7e84c55bcb6656...72ffda4fb66f1af42f11a5dc5d3c8b17a100c97b\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">6ec44529…72ffda4f</a>.</p>\n<p>At this point, we should be able to run <code>stack build</code>, then <code>stack exec snap-starter</code> (or whatever your project is called). You should see a basic site served on port 8000.</p>\n<p>Another thing to note in the project cabal file is that there’s a flag for compiling in development mode. This changes some of the behaviour in <code>Main.hs</code> to enable hot-reloading of the site on each request. This obviously slows it down significantly, but also speeds up development time.</p>\n<h5 id=\"sidenote--gitignores\" style=\"position:relative;\"><a href=\"#sidenote--gitignores\" aria-label=\"sidenote  gitignores permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Sidenote – gitignores</h5>\n<p>The standard snap template, and development builds, leave some files around that we won’t want to commit into version control. For this reason it’s a good idea to add a <code>.gitignore</code> file. I’ve used the standard GitHub Haskell file, with a few additions <a href=\"https://github.com/danpalmer/snap-starter/commit/6261a585bca5a5d7e1b5e153f2e0fd90b2e6ba4c\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">6261a585</a>.</p>\n<p>In addition to this, later on, the auth and persistent snaplets will write development configuration files. You may want to ignore these, depending on your development process.</p>\n<h3 id=\"adding-a-database\" style=\"position:relative;\"><a href=\"#adding-a-database\" aria-label=\"adding a database permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Adding a database</h3>\n<p>We can use a snaplet to provide an adapter to a Persistent-based database backend. This gives us the advantages of easy model definitions, type-safe querying, and so on, but requires a little set-up. There’s a handy [snaplet-persistent], but unfortunately it’s a little out of date and won’t work with our current dependencies. For now, I’ve forked a version and bumped the dependencies, but this is so far untested <a href=\"https://github.com/danpalmer/snap-starter/commit/941b4d299731efcf909eb16200e8e56eb0b94e56\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">941b4d29</a>.</p>\n<p>First off, let’s define a simple model to use for testing.</p>\n<pre class=\"grvsc-container github-plus\" data-language=\"haskell\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"mtk6\">module</span><span class=\"mtk1\"> Models </span><span class=\"mtk6\">where</span></span>\n<span class=\"grvsc-line\"></span>\n<span class=\"grvsc-line\"><span class=\"mtk6\">import</span><span class=\"mtk1\"> Database.Persist.TH</span></span>\n<span class=\"grvsc-line\"></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">share [mkPersist sqlSettings, mkMigrate </span><span class=\"mtk7\">&quot;migrateAll&quot;</span><span class=\"mtk1\">] [persistLowerCase</span><span class=\"mtk6\">|</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">  BlogPost</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    title String</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    content String</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    </span><span class=\"mtk6\">deriving</span><span class=\"mtk1\"> </span><span class=\"mtk4\">Eq</span><span class=\"mtk1\"> Show</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk6\">|</span><span class=\"mtk1\">]</span></span></code></pre>\n<p>Note: some extra language extensions are needed for this, read the <a href=\"https://github.com/danpalmer/snap-starter/commit/d4b15434e245e23cb4be97bcfa2db1a96e281548\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">full diff</a> for more details.</p>\n<p>We also need a few more packages <a href=\"https://github.com/danpalmer/snap-starter/commit/35aa5299d0d9a35636d6fe0d8c67b81d070b879c\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">35aa5299</a>.</p>\n<p>Next up Persistent requires some state, specifically a connection pool, which we can add to our app state structure:</p>\n<pre class=\"grvsc-container github-plus\" data-language=\"haskell\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"mtk6\">import</span><span class=\"mtk1\"> Snap.Snaplet.Persistent</span></span>\n<span class=\"grvsc-line\"></span>\n<span class=\"grvsc-line\"><span class=\"mtk6\">data</span><span class=\"mtk1\"> </span><span class=\"mtk6\">App</span><span class=\"mtk1\"> </span><span class=\"mtk6\">=</span><span class=\"mtk1\"> App</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    { _heist </span><span class=\"mtk6\">::</span><span class=\"mtk1\"> </span><span class=\"mtk6\">Snaplet</span><span class=\"mtk1\"> (</span><span class=\"mtk6\">Heist</span><span class=\"mtk1\"> </span><span class=\"mtk6\">App</span><span class=\"mtk1\">)</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    , _sess </span><span class=\"mtk6\">::</span><span class=\"mtk1\"> </span><span class=\"mtk6\">Snaplet</span><span class=\"mtk1\"> </span><span class=\"mtk6\">SessionManager</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    , _auth </span><span class=\"mtk6\">::</span><span class=\"mtk1\"> </span><span class=\"mtk6\">Snaplet</span><span class=\"mtk1\"> (</span><span class=\"mtk6\">AuthManager</span><span class=\"mtk1\"> </span><span class=\"mtk6\">App</span><span class=\"mtk1\">)</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    , _db </span><span class=\"mtk6\">::</span><span class=\"mtk1\"> </span><span class=\"mtk6\">Snaplet</span><span class=\"mtk1\"> </span><span class=\"mtk6\">PersistState</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    }</span></span></code></pre>\n<p>We can then initialise this state when we make our snaplet:</p>\n<pre class=\"grvsc-container github-plus\" data-language=\"haskell\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"mtk4\">app</span><span class=\"mtk1\"> </span><span class=\"mtk6\">::</span><span class=\"mtk1\"> </span><span class=\"mtk6\">SnapletInit</span><span class=\"mtk1\"> </span><span class=\"mtk6\">App</span><span class=\"mtk1\"> </span><span class=\"mtk6\">App</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">app </span><span class=\"mtk6\">=</span><span class=\"mtk1\"> makeSnaplet </span><span class=\"mtk7\">&quot;app&quot;</span><span class=\"mtk1\"> </span><span class=\"mtk7\">&quot;An snaplet example application.&quot;</span><span class=\"mtk1\"> Nothing </span><span class=\"mtk6\">$</span><span class=\"mtk1\"> </span><span class=\"mtk6\">do</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    </span><span class=\"mtk3\">-- ...</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    p </span><span class=\"mtk6\">&lt;-</span><span class=\"mtk1\"> nestSnaplet </span><span class=\"mtk7\">&quot;&quot;</span><span class=\"mtk1\"> db </span><span class=\"mtk6\">$</span><span class=\"mtk1\"> initPersist (runMigrationUnsafe migrateAll)</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    </span><span class=\"mtk3\">-- ...</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    return </span><span class=\"mtk6\">$</span><span class=\"mtk1\"> App h s a p</span></span></code></pre>\n<p>When initialising the Persistent snaplet, we can pass it a function to run within the SQL context once initialised. The intented use of this is that we can run our migrations, so we just pass the migration function that Persistent generates for us.</p>\n<h3 id=\"persistent-authentication\" style=\"position:relative;\"><a href=\"#persistent-authentication\" aria-label=\"persistent authentication permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Persistent Authentication</h3>\n<p>The snap template includes a basic authentication system for us which backs on to a flat JSON file on disk. While the auth system is relatively capable, a JSON flat file isn’t an ideal backend, and although snap ships with a <a href=\"https://hackage.haskell.org/package/postgresql-simple\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">postgresql-simple</a> backend, it would be nice to use Persistent so that we can enforce foreign key constraints and types in Haskell.</p>\n<p>Thankfully, <code>snaplet-persistent</code> ships with a backend for it, and with a quick modification to the authentication system’s initialisation, we can take adavantage of it <a href=\"https://github.com/danpalmer/snap-starter/commit/eef404a427daa206133b2ad7df0cd142f2afba95\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">eef404a4</a>. The only slightly tricky bit here is that we’ve got to pass the persistent auth manager the connection pool that’s buried within the persistent snaplet.</p>\n<pre class=\"grvsc-container github-plus\" data-language=\"haskell\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"mtk4\">app</span><span class=\"mtk1\"> </span><span class=\"mtk6\">::</span><span class=\"mtk1\"> </span><span class=\"mtk6\">SnapletInit</span><span class=\"mtk1\"> </span><span class=\"mtk6\">App</span><span class=\"mtk1\"> </span><span class=\"mtk6\">App</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">app </span><span class=\"mtk6\">=</span><span class=\"mtk1\"> makeSnaplet </span><span class=\"mtk7\">&quot;app&quot;</span><span class=\"mtk1\"> </span><span class=\"mtk7\">&quot;An snaplet example application.&quot;</span><span class=\"mtk1\"> Nothing </span><span class=\"mtk6\">$</span><span class=\"mtk1\"> </span><span class=\"mtk6\">do</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    </span><span class=\"mtk3\">-- ...</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    p </span><span class=\"mtk6\">&lt;-</span><span class=\"mtk1\"> nestSnaplet </span><span class=\"mtk7\">&quot;&quot;</span><span class=\"mtk1\"> db </span><span class=\"mtk6\">$</span><span class=\"mtk1\"> initPersist (runMigrationUnsafe migrateAll)</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    a </span><span class=\"mtk6\">&lt;-</span><span class=\"mtk1\"> nestSnaplet </span><span class=\"mtk7\">&quot;auth&quot;</span><span class=\"mtk1\"> auth </span><span class=\"mtk6\">$</span><span class=\"mtk1\"> initPersistAuthManager sess (persistPool </span><span class=\"mtk6\">$</span><span class=\"mtk1\"> view snapletValue p)</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    </span><span class=\"mtk3\">-- ...</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    return </span><span class=\"mtk6\">$</span><span class=\"mtk1\"> App h s a p</span></span></code></pre>\n<p>Finally, we need to ensure that the User model for authentication gets created in the database, which we can do by adding it to the list of entities that we’re going to create <a href=\"https://github.com/danpalmer/snap-starter/commit/c16d140f2d21592eb2ed2ac784d78f108d22c702\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">c16d140f</a>.</p>\n<pre class=\"grvsc-container github-plus\" data-language=\"haskell\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"mtk6\">import</span><span class=\"mtk1\"> Snap.Snaplet.Auth.Backends.Persistent (</span><span class=\"mtk4\">authEntityDefs</span><span class=\"mtk1\">)</span></span>\n<span class=\"grvsc-line\"></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">share [mkPersist sqlSettings, mkMigrate </span><span class=\"mtk7\">&quot;migrateAll&quot;</span><span class=\"mtk1\">] </span><span class=\"mtk6\">$</span><span class=\"mtk1\"> authEntityDefs </span><span class=\"mtk6\">++</span><span class=\"mtk1\"> [persistLowerCase</span><span class=\"mtk6\">|</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">  BlogPost</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    title String</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    content String</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    </span><span class=\"mtk6\">deriving</span><span class=\"mtk1\"> </span><span class=\"mtk4\">Eq</span><span class=\"mtk1\"> Show</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk6\">|</span><span class=\"mtk1\">]</span></span></code></pre>\n<p>When we compile and run this, we will be able to see Persistent creating the user model in the database.</p>\n<h3 id=\"querying-the-database\" style=\"position:relative;\"><a href=\"#querying-the-database\" aria-label=\"querying the database permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Querying the Database</h3>\n<p>The last step is to figure out how to query the database for useful results to display on a page.</p>\n<p>While Persistent does have a way to query the database, it’s low level, and designed to work for every persistent backend, rather than work well for relational databases. Because of this, I’m going to use <a href=\"https://hackage.haskell.org/package/esqueleto\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Esqueleto</a> instead, which provides an EDSL for SQL queries.</p>\n<p>After adding a few dependencies (<a href=\"https://github.com/danpalmer/snap-starter/commit/3a7274ae96105a4b0a5860e620a03f6cec155d1f\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">3a7274ae</a>) we must provide a way for Persistent to find the connection pool in our application state. To do this, we must implement <code>HasPersistPool</code> over the <code>Handler</code> for our app.</p>\n<pre class=\"grvsc-container github-plus\" data-language=\"haskell\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"mtk6\">instance</span><span class=\"mtk1\"> </span><span class=\"mtk6\">HasPersistPool</span><span class=\"mtk1\"> (</span><span class=\"mtk6\">Handler</span><span class=\"mtk1\"> a </span><span class=\"mtk6\">App</span><span class=\"mtk1\">) </span><span class=\"mtk6\">where</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    getPersistPool </span><span class=\"mtk6\">=</span><span class=\"mtk1\"> with db getPersistPool</span></span></code></pre>\n<p>Unfortunately, this isn’t all we need – some of our handlers use authentication, and therefore we’re actually running in a <code>Handler a (AuthManager App)</code> instead, so we also need an instance for that. With this instance, the <code>withTop</code> function is able to traverse back to our <code>App</code> state.</p>\n<pre class=\"grvsc-container github-plus\" data-language=\"haskell\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"mtk6\">instance</span><span class=\"mtk1\"> </span><span class=\"mtk6\">HasPersistPool</span><span class=\"mtk1\"> (</span><span class=\"mtk6\">Handler</span><span class=\"mtk1\"> </span><span class=\"mtk6\">App</span><span class=\"mtk1\"> (</span><span class=\"mtk6\">AuthManager</span><span class=\"mtk1\"> </span><span class=\"mtk6\">App</span><span class=\"mtk1\">)) </span><span class=\"mtk6\">where</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    getPersistPool </span><span class=\"mtk6\">=</span><span class=\"mtk1\"> withTop db getPersistPool</span></span></code></pre>\n<p>We can now write a query with Esqueleto. The full extent of this query is out of the scope of this blog post, but there’s some great documentation, and plenty of examples of Esqueleto around the web.</p>\n<pre class=\"grvsc-container github-plus\" data-language=\"haskell\" data-index=\"7\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"mtk4\">selectBlogPosts</span><span class=\"mtk1\"> </span><span class=\"mtk6\">::</span><span class=\"mtk1\"> </span><span class=\"mtk6\">MonadIO</span><span class=\"mtk1\"> m </span><span class=\"mtk6\">=&gt;</span><span class=\"mtk1\"> E.</span><span class=\"mtk6\">SqlPersistT</span><span class=\"mtk1\"> m [</span><span class=\"mtk6\">BlogPost</span><span class=\"mtk1\">]</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">selectBlogPosts </span><span class=\"mtk6\">=</span><span class=\"mtk1\"> </span><span class=\"mtk6\">do</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    posts </span><span class=\"mtk6\">&lt;-</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">        E</span><span class=\"mtk6\">.</span><span class=\"mtk1\">select </span><span class=\"mtk6\">$</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">        E</span><span class=\"mtk6\">.</span><span class=\"mtk1\">from </span><span class=\"mtk6\">$</span><span class=\"mtk1\"> </span><span class=\"mtk6\">\\</span><span class=\"mtk1\">blogPost </span><span class=\"mtk6\">-&gt;</span><span class=\"mtk1\"> </span><span class=\"mtk6\">do</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">            E</span><span class=\"mtk6\">.</span><span class=\"mtk1\">orderBy [E</span><span class=\"mtk6\">.</span><span class=\"mtk1\">asc (blogPost E</span><span class=\"mtk6\">.^.</span><span class=\"mtk1\"> BlogPostTitle)]</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">            E</span><span class=\"mtk6\">.</span><span class=\"mtk1\">limit </span><span class=\"mtk5\">3</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">            return blogPost</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    return </span><span class=\"mtk6\">$</span><span class=\"mtk1\"> E</span><span class=\"mtk6\">.</span><span class=\"mtk1\">entityVal </span><span class=\"mtk6\">&lt;$&gt;</span><span class=\"mtk1\"> posts</span></span></code></pre>\n<p>Finally, we can use this query to render a page. Here we first query for the blog posts, and then construct a splice for the blog posts that repeats its contents once for each element, along with child splices which expose the title and content of each post on each iteration through that list.</p>\n<pre class=\"grvsc-container github-plus\" data-language=\"haskell\" data-index=\"8\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"mtk4\">handleBlogPosts</span><span class=\"mtk1\"> </span><span class=\"mtk6\">::</span><span class=\"mtk1\"> </span><span class=\"mtk6\">Handler</span><span class=\"mtk1\"> </span><span class=\"mtk6\">App</span><span class=\"mtk1\"> (</span><span class=\"mtk6\">AuthManager</span><span class=\"mtk1\"> </span><span class=\"mtk6\">App</span><span class=\"mtk1\">) </span><span class=\"mtk5\">()</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">handleBlogPosts </span><span class=\"mtk6\">=</span><span class=\"mtk1\"> </span><span class=\"mtk6\">do</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">  blogPosts </span><span class=\"mtk6\">&lt;-</span><span class=\"mtk1\"> runPersist selectBlogPosts</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">  renderWithSplices </span><span class=\"mtk7\">&quot;blog_posts&quot;</span><span class=\"mtk1\"> (splices blogPosts)</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">  </span><span class=\"mtk6\">where</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    splices bps </span><span class=\"mtk6\">=</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">      </span><span class=\"mtk7\">&quot;blogPosts&quot;</span><span class=\"mtk1\"> </span><span class=\"mtk6\">##</span><span class=\"mtk1\"> I</span><span class=\"mtk6\">.</span><span class=\"mtk1\">mapSplices (I</span><span class=\"mtk6\">.</span><span class=\"mtk1\">runChildrenWith </span><span class=\"mtk6\">.</span><span class=\"mtk1\"> splicesFromBlogPost) bps</span></span>\n<span class=\"grvsc-line\"></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    splicesFromBlogPost p </span><span class=\"mtk6\">=</span><span class=\"mtk1\"> </span><span class=\"mtk6\">do</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">      </span><span class=\"mtk7\">&quot;title&quot;</span><span class=\"mtk1\"> </span><span class=\"mtk6\">##</span><span class=\"mtk1\"> I</span><span class=\"mtk6\">.</span><span class=\"mtk1\">textSplice (T</span><span class=\"mtk6\">.</span><span class=\"mtk1\">pack (blogPostTitle p))</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">      </span><span class=\"mtk7\">&quot;postContent&quot;</span><span class=\"mtk1\"> </span><span class=\"mtk6\">##</span><span class=\"mtk1\"> I</span><span class=\"mtk6\">.</span><span class=\"mtk1\">textSplice (T</span><span class=\"mtk6\">.</span><span class=\"mtk1\">pack (blogPostContent p))</span></span></code></pre>\n<p>The result of this (along with a few other imports and a template in <a href=\"https://github.com/danpalmer/snap-starter/commit/67f3b423d7fe1aa331b313f38461ba7ca0f4a09d\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">67f3b423</a>) is that we can visit <code>/posts</code> on our application and see a list of the top 3 posts, ordered by name ascending.</p>\n<hr>\n<p>That’s all for now. We have a barebones Snap application that uses the out of the box authentication, a database with an interface using Persistent for models and Esqueleto for querying, and we’ve seen how we can expose data to Heist for rendering HTML. The next things I’m looking at are form validation and background tasks, as both are crucial to a web application of any real complexity.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n  }\n  \n  .grvsc-code {\n    display: inline-block;\n    min-width: 100%;\n  }\n  \n  .grvsc-line {\n    display: inline-block;\n    box-sizing: border-box;\n    width: 100%;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-line-highlighted {\n    background-color: var(--grvsc-line-highlighted-background-color, transparent);\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, transparent);\n  }\n  \n  .github-plus {\n    background-color: #ffffff;\n    color: #24292e;\n  }\n  .github-plus .mtk6 { color: #D73A49; }\n  .github-plus .mtk1 { color: #24292EFF; }\n  .github-plus .mtk7 { color: #22863A; }\n  .github-plus .mtk4 { color: #6F42C1; }\n  .github-plus .mtk3 { color: #6A737D; }\n  .github-plus .mtk5 { color: #005CC5; }\n</style>","fields":{"slug":"/2016-06-19-starting-snap/"},"frontmatter":{"title":"Starting a Snap site with Stack and Persistent","theme":"light-gray-purple","originally_on_thread":null,"date":"19 June, 2016"}},"site":{"siteMetadata":{"title":"Dan Palmer","description":"Personal site and blog"}}},"pageContext":{"slug":"/2016-06-19-starting-snap/"}}}