{"componentChunkName":"component---src-components-post-post-jsx","path":"/2020-06-07-django-memcache-vulnerability/","result":{"data":{"markdownRemark":{"html":"<h1 id=\"information-exposure-vulnerability-with-django-and-memcached\" style=\"position:relative;\"><a href=\"#information-exposure-vulnerability-with-django-and-memcached\" aria-label=\"information exposure vulnerability with django and memcached permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Information Exposure Vulnerability with Django and Memcached</h1>\n<p>On Wednesday April 29th, Thread started experiencing a partial outage of our\nmain backend service. We traced the issue down to the existence of malformed\n<a href=\"memcached\">Memcached</a> keys and corrected the issue on <a href=\"thread\">thread.com</a>.\nAlong the way we suspected that this could be exploited on some <a href=\"django\">Django</a>\nsites using Memcached to cause private data exposure – either internal service\ndata or data about other users. The only issue on Thread was HTTP 500 server\nerrors seen by a small number of users, no private data was leaked.</p>\n<p>We reported this to the Django security team on the same day through their preferred <a href=\"disclosure\">disclosure process</a>, providing a full write up with a\npotential fix.</p>\n<p>After some discussion it was concluded that the issue did indeed represent a\nsecurity vulnerability in Django based sites, and was assigned the identifier\nCVE-2020-13254. The fix was reviewed and merged by the security team, and\nreleased in <a href=\"https://www.djangoproject.com/weblog/2020/jun/03/security-releases/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">3.0.7 and 2.2.13 on June 3rd</a>.</p>\n<p>This blog post covers…</p>\n<ul>\n<li><a href=\"#finding-the-vulnerability\"><strong>Finding the vulnerability</strong></a><br>\nWhat errors we saw, our debugging, and an unsatisfying conclusion.</li>\n<li><a href=\"#exploitation-example\"><strong>Exploitation example</strong></a><br>\nA simple Django example to show how this could be exploited.</li>\n<li><a href=\"#previous-related-django-discussion\"><strong>Previous related Django discussion</strong></a><br>\nThe history of this issue in Django, discussing why it may not have been realised sooner.</li>\n<li><a href=\"#why-should-django-validate-memcached-keys\"><strong>Why <em>should</em> Django validate Memcached keys?</strong></a><br>\nTechnical discussion of why the existing behaviour was incorrect.</li>\n<li><a href=\"#why-wasnt-this-found-sooner\"><strong>Why wasn’t this found sooner?</strong></a><br>\nDiscussion of why it’s easy to make these mistakes.</li>\n<li><a href=\"#reporting-and-fixing\"><strong>Reporting and fixing</strong></a><br>\nHow we reported and our experience contributing a fix to Django.</li>\n</ul>\n<hr>\n<h3 id=\"finding-the-vulnerability\" style=\"position:relative;\"><a href=\"#finding-the-vulnerability\" aria-label=\"finding the vulnerability permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Finding the vulnerability</h3>\n<p>This bug was one of the hardest I’ve investigated in a while with many dead\nends. We saw a number of symptoms indicating that cache queries of many kinds\nwere failing, but one of the clearest examples was this:</p>\n<pre class=\"grvsc-container github-plus\" data-language=\"python\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"mtk3\"># In `django/core/cache/backends/memcached.py`</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk6\">def</span><span class=\"mtk1\"> </span><span class=\"mtk4\">get_many</span><span class=\"mtk1\">(</span><span class=\"mtk13\">self</span><span class=\"mtk1\">, </span><span class=\"mtk13\">keys</span><span class=\"mtk1\">, </span><span class=\"mtk13\">version</span><span class=\"mtk6\">=</span><span class=\"mtk5\">None</span><span class=\"mtk1\">):</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    key_map </span><span class=\"mtk6\">=</span><span class=\"mtk1\"> {self.</span><span class=\"mtk4\">make_key(key, version</span><span class=\"mtk6\">=</span><span class=\"mtk4\">version)</span><span class=\"mtk1\">: key </span><span class=\"mtk6\">for</span><span class=\"mtk1\"> key </span><span class=\"mtk6\">in</span><span class=\"mtk1\"> keys}</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    ret </span><span class=\"mtk6\">=</span><span class=\"mtk1\"> self._cache.</span><span class=\"mtk4\">get_multi(key_map.keys())</span></span>\n<span class=\"grvsc-line\"></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    </span><span class=\"mtk3\"># `KeyError` on this line for key `b&#39;:1:alternate-colours:1:15492594:213&#39;`</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    </span><span class=\"mtk6\">return</span><span class=\"mtk1\"> {key_map[k]: v </span><span class=\"mtk6\">for</span><span class=\"mtk1\"> k, v </span><span class=\"mtk6\">in</span><span class=\"mtk1\"> ret.</span><span class=\"mtk4\">items()</span><span class=\"mtk1\">}</span></span>\n<span class=\"grvsc-line\"></span>\n<span class=\"grvsc-line\"><span class=\"mtk3\"># Where:</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">key_map </span><span class=\"mtk6\">=</span><span class=\"mtk1\"> {</span><span class=\"mtk6\">b</span><span class=\"mtk7\">&#39;:1:preferred-sizes-v2:88625:15492594&#39;</span><span class=\"mtk1\">: </span><span class=\"mtk7\">&#39;preferred-sizes-v2:88625:15492594&#39;</span><span class=\"mtk1\">}</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">v </span><span class=\"mtk6\">=</span><span class=\"mtk1\"> [</span><span class=\"mtk5\">15492576</span><span class=\"mtk1\">, </span><span class=\"mtk5\">15492582</span><span class=\"mtk1\">, </span><span class=\"mtk5\">15492619</span><span class=\"mtk1\">, </span><span class=\"mtk5\">15492641</span><span class=\"mtk1\">]</span></span></code></pre>\n<p>Django provides a <code>get_many</code> function on its cache backends system. This takes\nan iterable of keys, and returns a mapping from those keys to the values from\nthe cache, using the cache’s bulk query functionality if there is any.</p>\n<p>The issue here was that while the keys input to the function were\n<code>preferred-sizes</code> keys (for the sizes of products that are appropriate for a\ngiven user), the cache had returned in <code>ret</code> an <code>alternate-colours</code> value which\nthe cache backend was unable to match up with a key it was querying for, thus\nraising a <code>KeyError</code>.</p>\n<p>This had us stumped. It looked like the cache was giving back the wrong data,\nbut Memcached is a rock-solid piece of infrastructure, battle tested at\ncompanies far larger than us, so it was much more likely the bug was in our code.</p>\n<p>The first port of call was what new changes we had shipped. We ship to\nproduction up to 40 times a day, so this is often a hard question to answer, but\na suspicious commit had change a lot about how we use some of our core cached\ndata and how it’s serialised. We checked to make sure that the data in the cache\nfor given keys was valid, and it was, so we went down a rabbit hole of\ninvestigating serialisation behaviour, pickling (a Python form of serialisation)\nand a number of other issues. This turned out to be a dead end.</p>\n<p>Since the data was valid, and our querying and serialisation appeared to be\ncorrect, this suggested an issue between us and Memcached. After serveral hours\nwe suspected the issue could have been file pointers being re-used. If two\nprocesses could get access to the same file pointer, and were both writing\nqueries and attempting to read results, they could read each others results. We\nspent some time investigating how this could happen, but what convinced us that\nthis wasn’t the issue was that our incorrect responses from Memcached were not\n<em>malformed</em>, they were not truncated in the middle of keys or values, behaviour\nwe’d almost certainly see otherwise.</p>\n<p>Eventually a colleague who had been working on a separate area of the code, and\nwho had pushed changes that had not worked in production, asked us if it could\nbe related. He had found that through several layers of abstraction, a value\nthat he had been editing – a human-readable title – was ending up in a cache\nkey. He had updated some code with the first multi-word title and therefore\ninadvertently introduced a space character into a cache key, something not\nallowed by Memcached.</p>\n<p>By including spaces in cache keys, our connection was getting out of step with\nwhat data Memcached was responding with. This is best illustrated by the <a href=\"https://www.youtube.com/watch?v=BvmRI6K8TS8\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Two\nRonnies Mastermind sketch</a>.</p>\n<p>After a day of reading source code of Django, PyLibMC and the C source of\nlibmemcached, ruling out many possibilities such as inadvertently upgrading\npackages or processes sharing file descriptors, finding that this bug was\n“simply” a space in a cache key was a little disappointing. It does however\nillustrate how possible or even likely this is in other codebases, and how\ndangerous this could be.</p>\n<h3 id=\"exploitation-example\" style=\"position:relative;\"><a href=\"#exploitation-example\" aria-label=\"exploitation example permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Exploitation example</h3>\n<p>Exploiting this issue as a user of a website requires the following things:</p>\n<ul>\n<li>The website must be using Django, Memcached, and PyLibMC or another driver for\nMemcached that does not validate keys (note that python-memcached <em>does</em>\nvalidate keys and is not thought to be exploitable).</li>\n<li>User-control over content that will end up unprocessed in a cache key. This\ncould be a string, but could equally be a value associated with a form control.</li>\n<li>The website must be using the cache in such a way that cache keys referencing\nsensitive data are queried after those that can be controlled by the attacker\n– although this is not <em>per request</em> but over the lifetime of a server process.</li>\n</ul>\n<p>The full example is available on GitHub at\n<a href=\"https://github.com/danpalmer/django-cve-2020-13254\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">danpalmer/django-cve-2020-13254</a>.</p>\n<p>The example codebase demonstrates the exploitation in two ways, via a simple\nweb interface and via a failing test case.</p>\n<h5 id=\"exploiting-via-the-web\" style=\"position:relative;\"><a href=\"#exploiting-via-the-web\" aria-label=\"exploiting via the web permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Exploiting via the web</h5>\n<p>The example provides a web interface with 2 forms, one that sets values in the\ncache and the other that gets them. These are directly translated into calls to\nthe Django cache backend. Because the codebase does not implement any session or\nauthentication system, multiple uses in the same browser tab are\nindistinguishable from multiple users using between machines.</p>\n<p>To exploit:</p>\n<ol>\n<li>Set keys of <strong>A</strong> and <strong>B</strong> to values <strong>a</strong> and <strong>b</strong>.</li>\n<li>Attempt to set <strong>C D</strong> to value <strong>c d</strong>. This will error.</li>\n<li>Attempt to retrieve key <strong>A</strong>, there will incorrectly be no result.</li>\n<li>Attempt to retrieve key <strong>B</strong>, the result will incorrectly be <strong>a</strong>.</li>\n</ol>\n<h5 id=\"demo-via-tests\" style=\"position:relative;\"><a href=\"#demo-via-tests\" aria-label=\"demo via tests permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Demo via tests</h5>\n<p>This process can be expressed as a test case as such:</p>\n<pre class=\"grvsc-container github-plus\" data-language=\"python\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"mtk6\">from</span><span class=\"mtk1\"> django.core.cache </span><span class=\"mtk6\">import</span><span class=\"mtk1\"> cache</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk6\">from</span><span class=\"mtk1\"> django.test </span><span class=\"mtk6\">import</span><span class=\"mtk1\"> TestCase</span></span>\n<span class=\"grvsc-line\"></span>\n<span class=\"grvsc-line\"></span>\n<span class=\"grvsc-line\"><span class=\"mtk6\">class</span><span class=\"mtk1\"> </span><span class=\"mtk4\">CacheTests</span><span class=\"mtk1\">(</span><span class=\"mtk4\">TestCase</span><span class=\"mtk1\">):</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">    </span><span class=\"mtk6\">def</span><span class=\"mtk1\"> </span><span class=\"mtk4\">test_cache</span><span class=\"mtk1\">(</span><span class=\"mtk13\">self</span><span class=\"mtk1\">):</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">        cache.</span><span class=\"mtk4\">set(</span><span class=\"mtk7\">&#39;k1&#39;</span><span class=\"mtk4\">, </span><span class=\"mtk7\">&#39;v1&#39;</span><span class=\"mtk4\">)</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">        cache.</span><span class=\"mtk4\">set(</span><span class=\"mtk7\">&#39;k2&#39;</span><span class=\"mtk4\">, </span><span class=\"mtk7\">&#39;v2&#39;</span><span class=\"mtk4\">)</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">        </span><span class=\"mtk6\">try</span><span class=\"mtk1\">:</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">            cache.</span><span class=\"mtk4\">set(</span><span class=\"mtk7\">&#39;a b&#39;</span><span class=\"mtk4\">, </span><span class=\"mtk7\">&#39;v3&#39;</span><span class=\"mtk4\">)</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">        </span><span class=\"mtk6\">except</span><span class=\"mtk1\"> </span><span class=\"mtk5\">Exception</span><span class=\"mtk1\">:</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">            </span><span class=\"mtk6\">pass</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk1\">        self.</span><span class=\"mtk4\">assertEqual(</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk4\">            [</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk4\">              cache.get(x) </span><span class=\"mtk6\">for</span><span class=\"mtk4\"> x </span><span class=\"mtk6\">in</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk4\">              [</span><span class=\"mtk7\">&#39;k2&#39;</span><span class=\"mtk4\">, </span><span class=\"mtk7\">&#39;k1&#39;</span><span class=\"mtk4\">, </span><span class=\"mtk7\">&#39;k2&#39;</span><span class=\"mtk4\">, </span><span class=\"mtk7\">&#39;k1&#39;</span><span class=\"mtk4\">, </span><span class=\"mtk7\">&#39;k2&#39;</span><span class=\"mtk4\">, </span><span class=\"mtk7\">&#39;k1&#39;</span><span class=\"mtk4\">]</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk4\">            ],</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk4\">            [</span><span class=\"mtk7\">&#39;v2&#39;</span><span class=\"mtk4\">, </span><span class=\"mtk7\">&#39;v1&#39;</span><span class=\"mtk4\">, </span><span class=\"mtk7\">&#39;v2&#39;</span><span class=\"mtk4\">, </span><span class=\"mtk7\">&#39;v1&#39;</span><span class=\"mtk4\">, </span><span class=\"mtk7\">&#39;v2&#39;</span><span class=\"mtk4\">, </span><span class=\"mtk7\">&#39;v1&#39;</span><span class=\"mtk4\">],</span></span>\n<span class=\"grvsc-line\"><span class=\"mtk4\">        )</span></span></code></pre>\n<p>This fails with the following error:</p>\n<pre class=\"grvsc-container github-plus\" data-language=\"\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\">=============================================================</span>\n<span class=\"grvsc-line\">FAIL: test_cache (demo.tests.CacheTests)</span>\n<span class=\"grvsc-line\">-------------------------------------------------------------</span>\n<span class=\"grvsc-line\">Traceback (most recent call last):</span>\n<span class=\"grvsc-line\">  File &quot;tests.py&quot;, line 30, in test_cache</span>\n<span class=\"grvsc-line\">    &#39;v1&#39;,</span>\n<span class=\"grvsc-line\">AssertionError: Lists differ</span>\n<span class=\"grvsc-line\"></span>\n<span class=\"grvsc-line\">First differing element 0:</span>\n<span class=\"grvsc-line\">None</span>\n<span class=\"grvsc-line\">&#39;v2&#39;</span>\n<span class=\"grvsc-line\"></span>\n<span class=\"grvsc-line\">- [None, &#39;v2&#39;, &#39;v1&#39;, &#39;v2&#39;, &#39;v1&#39;, &#39;v2&#39;]</span>\n<span class=\"grvsc-line\">?  ------</span>\n<span class=\"grvsc-line\"></span>\n<span class=\"grvsc-line\">+ [&#39;v2&#39;, &#39;v1&#39;, &#39;v2&#39;, &#39;v1&#39;, &#39;v2&#39;, &#39;v1&#39;]</span>\n<span class=\"grvsc-line\">?                              ++++++</span>\n<span class=\"grvsc-line\"></span>\n<span class=\"grvsc-line\">-------------------------------------------------------------</span></code></pre>\n<p>As you can see, after the <code>set</code>, the cache results being returned are out of\nstep with the queries being made.</p>\n<h3 id=\"previous-related-django-discussion\" style=\"position:relative;\"><a href=\"#previous-related-django-discussion\" aria-label=\"previous related django discussion permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Previous related Django discussion</h3>\n<p>During investigation we found that Django already validates cache keys to ensure\nthat they do not contain spaces, as well as validating that they don’t include a\nnumber of other invalid characters and are under the maximum key length.\nUnfortunately this validation <em>only happens on non-Memcached backends</em>, and this\nwas intentional!</p>\n<p>From reading into the history it seems that in the pursuit of speed in some\nplaces, and developer experience in others, each applied unevenly, we ended up\nin this strange position where the backends that do not need it have it, and\nthose that do don’t.</p>\n<h5 id=\"2008\" style=\"position:relative;\"><a href=\"#2008\" aria-label=\"2008 permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2008</h5>\n<p>In January 2008 issue <a href=\"6447\">#6447</a> was opened on Django’s bug tracker. It\nessentially suggests that because Memcached has these limitations, the cache\nbackends used for local development (which just store the cache in process,\nunsuitable for production) should also do the same validation so that a\ndeveloper using development backends locally but Memcached in production won’t\nbe bitten by cache key validity issues once they deliver their code to production.</p>\n<h5 id=\"2010\" style=\"position:relative;\"><a href=\"#2010\" aria-label=\"2010 permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2010</h5>\n<p>On the same ticket it is decided that warnings (but not errors) will be added to\nnon-Memcached backends to help, but that they won’t be added to the Memcached\nbackend itself because:</p>\n<blockquote>\n<p>any key mangling there could slow down a critical code path</p>\n</blockquote>\n<p>While this dedication to performance is commendable, the key validation here is\nsimple string checking on strings that must be 255 characters or shorter anyway\n(the Memcached key limit). This is not only likely to be a very quick operation,\nit’s also happening during a cache query that would incur a network round-trip.</p>\n<h5 id=\"2013\" style=\"position:relative;\"><a href=\"#2013\" aria-label=\"2013 permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2013</h5>\n<p>In February 2013 it was reported in <a href=\"19914\">#19914</a> that the test suite for\nDjango was failing when using PyLibMC and the Memcached cache backend. During\nthe investigation it was found that including spaces in a cache key…</p>\n<blockquote>\n<p>causes subsequent requests to the server … to fail for the next few seconds</p>\n</blockquote>\n<p>The conclusion of this ticket was to remove the offending test from the\nmemcached backend test suite for PyLibMC.</p>\n<h3 id=\"why-should-django-validate-memcached-keys\" style=\"position:relative;\"><a href=\"#why-should-django-validate-memcached-keys\" aria-label=\"why should django validate memcached keys permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Why <em>should</em> Django validate Memcached keys?</h3>\n<p>Throughout these tickets, the matter of whether Django should be validating keys\ncame up several times, but why? As mentioned by commenters on those tickets,\nwouldn’t it be faster not to? Maybe it’s not Django’s repsonsibility to validate\nthese keys.</p>\n<p>From the famous <a href=\"numbers\">Numbers Every Programmer Should Know</a> (from 2009, so\nrepresentative of the time this was being worked on), a main memory reference is\naround 100ns and a round-trip network request within the same datacentre is\n500,000ns. The string validation may take a few memory accesses, so we could\ncall it 1,000ns<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>, but even then we’re still looking at a ~0.2% overhead on a\ncache query.</p>\n<p>From this perspective it’s likely not that impactful, but another perspective is\nwhat level of abstraction we’re working at. Django is a relatively high level\nweb framework – it aims to provide easy to use and safe tools for most things\nthat web developers need to do. It does not aim to be the highest performance\nframework out there and such a framework would also likely not be based on\nPython. Django and Python already make speed trade-offs for developer\nproductivity and safety, incurring performance overheads for preventing\nsegfaults or making SQL injection attacks much less of a risk.</p>\n<p>It’s worth noting that libmemcached also does not validate keys by default. This\nis probably much more appropriate as libmemcached is not designed to be a safe\ntool for working with caches, it’s designed to be a fast interface to Memcached\nthat gives all control possible to the developer. A lack of validation here is\nappropriate for the level of abstraction that libmemcached provides.</p>\n<p>Within the context of Django’s aims and Python’s values, skipping the validation\nto save this time is likely the wrong design choice, and the lack of impact\nmeans it’s probably the wrong technical choice, but it’s easy to get stuck in a\nperformance focused view of code and forget about developer experience.</p>\n<h3 id=\"why-wasnt-this-found-sooner\" style=\"position:relative;\"><a href=\"#why-wasnt-this-found-sooner\" aria-label=\"why wasnt this found sooner permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Why wasn’t this found sooner?</h3>\n<p>The ticket in 2013 came so close to realising the potential security issues,\nfinding the exact behaviour that we at Thread observed, but missing the impact\nthat it could have on a production system being used by untrusted users.</p>\n<p>Having a security focused mindset is <em>hard</em>, it’s something I practice as much\nas I can, but as developers it’s much easier to focus on what software <em>should</em>\ndo rather than what it <em>shouldn’t</em>. I can’t fault the Django team for not\nspotting this, the reason we joined the dots at Thread was because we were\nseeing cache keys and values containing user IDs in our error monitoring,\nwithout this we may well have not realised the impact.</p>\n<p>Despite multiple people looking at this specific issue over the last ~10 years,\nno one raised it (publicly) as a security vulnerability. Even at Thread, it was\nonly after three of us had worked on the bug we were investigating, and all\nwondered aloud if it could be a security vulnerability <em>for us</em>, did we finally\nconnect the dots and realise that this <em>was</em> an issue that would likely affect\nother sites should probably be fixed in Django.</p>\n<h3 id=\"reporting-and-fixing\" style=\"position:relative;\"><a href=\"#reporting-and-fixing\" aria-label=\"reporting and fixing permalink\" class=\"header-link before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reporting and fixing</h3>\n<p>I wrote up a full description of the issue, along with a first-pass attempt at a\nfix for it in Django and sent this to the security team. Django thankfully\npublishes contact details for its security team and also explicitly mentions\nthese details in their bug tracker, encouraging developers not to submit public\nbugs that could have a security impact. This is great practice for a framework\nbehind millions of websites running in production.</p>\n<p>I received a response confirming that they had received the report within a few\nhours. Several days later, the team had a short discussion on the email chain\nraising questions and pointing to tickets where this had been discussed before,\nalbeit without the security perspective.</p>\n<p>After some back and forth it was confirmed on May 6th that this was indeed an\nexploitable security vulnerability and that it should be fixed in Django.</p>\n<p>I finished my patch, including tests and documentation fixes, and submitted on\nMay 8th. This was reviewed and accepted by the team.</p>\n<p>The Django security team scheduled the patch for release in <a href=\"https://www.djangoproject.com/weblog/2020/jun/03/security-releases/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">3.1a2, 3.0.7 and\n2.2.13 on June 1st</a>.</p>\n<p>This whole process was very easy thanks to the Django security team. It’s easy\nto be defensive when someone tells you there is a security vulnerabiliy in your\nproduct, but they came to the process with no ego. I already find the Django\ncommunity to be helpful, friendly, and professional, and this process has served\nto further cement that feeling.</p>\n<hr>\n<p>One thing I’ll be taking away from this experience is that it’s not always\nobvious when something is a security issue. It’s a nuanced balance of how code\nis used in production, attack vectors that might be levels of abstraction away,\nwhat the developer believes they are expected to do, and whether it’s\nappropriate from a performance perspective.</p>\n<p>Thanks again to the Django security team, and also to my colleagues Alistair\nLynn and Aaron Kirkbride, who both aided in debugging the issue and coming to\nthe realisation of the wider impact of the bug.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n  }\n  \n  .grvsc-code {\n    display: inline-block;\n    min-width: 100%;\n  }\n  \n  .grvsc-line {\n    display: inline-block;\n    box-sizing: border-box;\n    width: 100%;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-line-highlighted {\n    background-color: var(--grvsc-line-highlighted-background-color, transparent);\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, transparent);\n  }\n  \n  .github-plus {\n    background-color: #ffffff;\n    color: #24292e;\n  }\n  .github-plus .mtk3 { color: #6A737D; }\n  .github-plus .mtk6 { color: #D73A49; }\n  .github-plus .mtk1 { color: #24292EFF; }\n  .github-plus .mtk4 { color: #6F42C1; }\n  .github-plus .mtk13 { color: #E27F2D; }\n  .github-plus .mtk5 { color: #005CC5; }\n  .github-plus .mtk7 { color: #22863A; }\n</style>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p>  This is certainly debatable, but given a <em>valid</em> key is a maximum of 255\ncharacters, we’re likely talking about a maximum of 250-500 bytes assuming\nthat most cache keys are ASCII or common extensions expressable in 2-bytes of\nunicode data as most written languages are. 500 bytes of a string being\nanalysed will likely be loaded into the CPU cache in under 10 operations.</p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","fields":{"slug":"/2020-06-07-django-memcache-vulnerability/"},"frontmatter":{"title":"CVE-2020-13254","theme":null,"originally_on_thread":null,"date":"07 June, 2020"}},"site":{"siteMetadata":{"title":"Dan Palmer","description":"Personal site and blog"}}},"pageContext":{"slug":"/2020-06-07-django-memcache-vulnerability/"}}}